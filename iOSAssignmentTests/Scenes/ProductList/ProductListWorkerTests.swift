//
//  ProductListWorkerTests.swift
//  iOSAssignment
//
//  Created by David Velarde on 18/12/2021.
//  Copyright (c) 2021 ___ORGANIZATIONNAME___. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

@testable import iOSAssignment
import XCTest

class ProductListWorkerTests: XCTestCase {
  
    // MARK: Subject under test
    
    var sut: ProductListWorker!
    
    // MARK: Test lifecycle
  
    override func setUp() {
        super.setUp()
        setupProductListWorker()
    }
  
    override func tearDown() {
        super.tearDown()
    }
  
    // MARK: Test setup
  
    enum Possibilities {
        case undefined
        case empty
        case filled
    }
    
    class ProductRepositorySpy: ProductsRepositoryType {
        var possibility: Possibilities = .empty
        func fetchRawProducts() -> Products? {
            switch possibility {
            case .empty:
                return Products(products: [ProductRaw]())
            case .undefined:
                return nil
            case .filled:
                return Products(products: Array(0..<100).map({ Product.create(withId: "\($0)") }))
            }
        }
    }
    
    func setupProductListWorker() {
        sut = ProductListWorker()
    }
  
    // MARK: Test doubles
  
    // MARK: Tests
  
    func testGetProductsWithRange() {
        // Given
        let spy = ProductRepositorySpy()
        spy.possibility = .filled
        sut.productRepository = spy
        
        // When
        var products: Products?
        let expectation = self.expectation(description: "Waiting to fetch products")
        sut.getProducts(start: 0, amount: 10) { p in
            products = p
            expectation.fulfill()
        }
        waitForExpectations(timeout: 5, handler: nil)
        
        // Then
        XCTAssertEqual(products?.products.count, 10, "There should only be 10 products returned")
        XCTAssertEqual(products?.products.first?.id, "0", "The first item should have id 0")
        XCTAssertEqual(products?.products.last?.id, "9", "The last item should have id 9")
    }
    
    func testGetMoreProductsWithRange() {
        // Given
        let spy = ProductRepositorySpy()
        spy.possibility = .filled
        sut.productRepository = spy
        
        // When
        var products: Products?
        let expectation = self.expectation(description: "Waiting to fetch products")
        sut.getProducts(start: 10, amount: 20) { p in
            products = p
            expectation.fulfill()
        }
        waitForExpectations(timeout: 5, handler: nil)
        
        // Then
        XCTAssertEqual(products?.products.count, 20, "There should only be 20 products returned")
        XCTAssertEqual(products?.products.first?.id, "10", "The first item should have id 10")
        XCTAssertEqual(products?.products.last?.id, "29", "The last item should have id 29")
    }
    
    func testGetProductsWithRangeExceeding() {
        // Given
        let spy = ProductRepositorySpy()
        spy.possibility = .filled
        sut.productRepository = spy
        
        // When
        var products: Products?
        let expectation = self.expectation(description: "Waiting to fetch products")
        sut.getProducts(start: 90, amount: 15) { p in
            products = p
            expectation.fulfill()
        }
        waitForExpectations(timeout: 5, handler: nil)
        
        // Then
        XCTAssertEqual(products?.products.count, 10, "There should only be 10 products returned")
        XCTAssertEqual(products?.products.first?.id, "90", "The first item should have id 90")
        XCTAssertEqual(products?.products.last?.id, "99", "The last item should have id 99")
    }
    
    func testGetProductsWithImpossibleRange() {
        // Given
        let spy = ProductRepositorySpy()
        spy.possibility = .filled
        sut.productRepository = spy
        
        // When
        var products: Products?
        let expectation = self.expectation(description: "Waiting to fetch products")
        sut.getProducts(start: 105, amount: 10) { p in
            products = p
            expectation.fulfill()
        }
        waitForExpectations(timeout: 5, handler: nil)
        
        // Then
        XCTAssertTrue(products?.products.isEmpty ?? false, "There should not be products returned")
    }
    
    func testGetProductsWhenNoProductsAvailable() {
        // Given
        let spy = ProductRepositorySpy()
        spy.possibility = .empty
        sut.productRepository = spy
        // When
        var products: Products?
        let expectation = self.expectation(description: "Waiting to fetch products")
        sut.getProducts(start: 0, amount: 10) { p in
            products = p
            expectation.fulfill()
        }
        waitForExpectations(timeout: 5, handler: nil)
        // Then
        XCTAssertTrue(products?.products.isEmpty ?? false, "There should not be products returned")
    }
    
    func testGetProductsWhenProductFailToBeReturned() {
        // Given
        let spy = ProductRepositorySpy()
        spy.possibility = .undefined
        sut.productRepository = spy
        // When
        var products: Products?
        let expectation = self.expectation(description: "Waiting to fetch products")
        sut.getProducts(start: 0, amount: 10) { p in
            products = p
            expectation.fulfill()
        }
        waitForExpectations(timeout: 5, handler: nil)
        // Then
        XCTAssertTrue(products?.products.isEmpty ?? false, "There should not be products returned")
    }
}
